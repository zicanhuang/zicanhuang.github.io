---
layout: post
title: 公平调度
date: 2018-11-30
categories: storage
tags: Markdown
---

# 一、linux中公平调度机制(CFQ)
首先这个公平指的是对进程的公平，即操作系统在多个进程竞争IO资源时试图让进程可以公平地使用IO资源。

IO资源往往有两种衡量方式，带宽和IOPS，当请求大小很大时或请求地址比较连续时，带宽容易成为瓶颈；而当请求大小比较小、并且多是随机请求（难以合并）时，IOPS容易成为瓶颈。因为操作系统并不知道进程倾向于以哪种方式利用IO资源，因此操作系统采用对IO设备的占用时间来进行调度，即尽可能地让各个进程公平地占用IO设备的时间。

linux默认采用CFQ(Completely Fair Queueing)来保证进程间公平地使用IO资源。

新版的CFQ支持cgroup，全部进程被分成了若干个cgroup进行管理。cgroup有policy，policy限定cgroup对IO资源的访问上限。CFQ记录每个cgroup占用的IO时间(vdisktime)，这个时间是虚拟时间，即实际占用IO时间/cgroup的权值，这个权值是根据cgroup的policy定的。所以CFQ对于cgroup之间的管理策略是：
每次分配一个时间片，这个时间片分配给vdisktime最小的cgroup。分配比例大的cgroup虚拟IO时间增长地慢，分配比例小的cgroup虚拟IO时间增长的快，以此来保证各个cgroup之间成比例地占用IO资源。从实现上，所有的cgroup被放在一棵红黑树里，以vdisktime为key进行排序，每次从红黑树中选出vdisktime最小的cgroup进行处理。

在同一个cgroup里面，CFQ保证进程间的IO资源分配公平。

进程是有优先级的，可以通过nice命令设置进程的优先级。所以CFQ其实是保证了同一个cgroup中同一个优先级内的进程在IO访问时间上是公平的，不同优先级之间优先级高的先访问，分成三种优先级RT(RealTime)，BE(BestEffort)和IDLE，RT优先级最高，只有当没有RT进程访问IO资源时，BE进程才能访问IO资源。

在同一个优先级中，每个进程有一个服务队列cfq_queue，CFQ每次把时间片分配给IO服务时间(service_time)最小的cfq_queue，所以这里又用一棵红黑树维护了各个进程的服务队列，以service_time为key。

当选择好了cfq_queue后，就要从队列中选择一个请求进行派发。对每个进入cfq_queue的请求会放入两个数据结构中：一个是FIFO的队列，用来避免请求超时，一个是以访问扇区为key的红黑树。默认从红黑树中取请求进行处理，当FIFO队头的请求达到deadline时处理该请求，防止请求饿死。

另外提一句：linux中同步请求和异步请求是分开处理的，因为只有当请求是同步的时候CFQ才能区分IO请求来自哪个进程，这里说的异步指的是进程把数据先写到buffer/cache，后台再从内存的buffer/cache中把数据同步到硬盘的IO请求。(而非aio或libaio机制，这些上层的异步机制，在内核中都是同步实现的)。

# 二、WFQ(Weighted Fair Queueing)
这篇论文(Analysis and simulation of a fair queueing algorithm)引用量接近3000，可谓是公平调度中的鼻祖。
WFQ主要focus其实是网络包的拥塞控制，初衷是为了 通过排队算法提供一种保护机制，使得ill-behaved的包来源只能对其他包来源造成有限的影响。


# 三、SFQ(Start-time Fair Queueing)

# 四、SFQ(D)

# 五、FIOS: 一种公平有效的闪存IO调度器(FAST'12)


# 六、FlashFQ:一种针对SSD的IO公平排队调度器(ATC’13)


